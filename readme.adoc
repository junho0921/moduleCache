= 模块缓存
188630703@qq.com
:toc: left
:toclevels: 3
:toc-title: 目录
:numbered:
:sectanchors:
:sectlinks:
:sectnums:

:imagesdir: ./images
:stylesdir: ./styles

== 前言

本缓存说明书是以框架nuui作为研究环境.

nuui框架是移动端的SPA框架.

使用技术:`Backbone, Backbone.Marionette, RequireJs, jQuery, gulp, nodejs, underscore, asciidoc, Browserify`


== 关于缓存

=== 缓存是什么

缓存就是数据交换的缓冲区。

浏览器缓存节约了网络的资源加速浏览,浏览器在用户磁盘上对最近请求过的文档进行存储,当访问者再次请求这个页面时,浏览器就可以从本地磁盘显示文档,这样就可以加速页面的阅览。很好的优化了用户体验。

=== 浏览器缓存cache 特点

. 各浏览器的缓存机制不同，我们以下方案是基于这种假设：

.. 若url相同，文件一直缓存;

.. 若url变化了，文件不缓存;

. 生命周期( 生命时间未知，我们可以假设生命周期很长 )

== 关于模块缓存

=== 模块相关的缓存变量

//==== `Backbone.Router`
//
//* 具体变量:   `Backbone.history.handlers`
//* 内容:   锚点对应的方法, 包含`view`渲染方法
//* 用处:   用户访问`view`的渲染方法都来源于此缓存
//* 保留的意义:   `view`作为模块的部分有随时被渲染的需要
//* 删除的情形:   模块不会被访问, 其`view`不会渲染
//
//==== `RequireJs`
//
//* 具体变量:   `require.urlFetched`, `require.defined`, `script`
//* 内容:   模块输出
//* 用处:   避免重复加载模块
//* 保留的意义:   缓存模块可能被新模块引用
//* 删除的情形:   缓存模块不会被新模块引用

|===
|组件 |具体变量 |缓存内容 |缓存的用处 |保留的意义 |不需要的情景

| `Backbone.Router`
| `Backbone.history.handlers`
| 锚点对应的方法, 包含`view`渲染方法
| 用户访问`view`的渲染方法都来源于此缓存
| `view`作为模块的部分有随时被渲染的需要
| 模块不会被访问, 其`view`不会渲染

| `RequireJs`
| `require.urlFetched`, `require.defined`, `script`
| 模块输出
| 避免重复加载模块
| 缓存模块可能被新模块引用
| 缓存模块不会被新模块引用

|===

//view的渲染js与渲染html是一次性加载的
//
//=== 页面实例化的组件会在view切换时被jQ的缓存清理工具清理好

=== 模块缓存添加的过程

模块的缓存添加非一步到位, 涉及以下五个缓存变量的添加.

==== 添加顺序

1. require.urlFetched
2. require.script
3. require.defined
4. Backbone.history.handlers
5. moduleStates // nuui框架中的记录模块缓存的变量

==== 特点

单个模块::
* 时间漫长
* 第二点到第三点的时间间隔受网络速度影响
* 前三点是反复添加的过程, 时间间隔受网络速度影响
* 若模块一直加载, 没有成功, 那么只有前两三点有缓存, 而且, 页面的输出没有构造实例, 所以不应该计入已加载模块数量,

多个模块的特点:: 无序

=== 模块缓存带来的问题

若不断向浏览器加载模块, 多数具体页面的渲染模块与模板模块是不会复用的, 若不清理这些, 会影响浏览器内存.

== 如何清理模块缓存

=== 如何定义一个模块缓存的成功添加

由于缓存的添加是不稳定且耗时长的特点, 我们应该以单个模块的缓存添加为操作单位, 即过程忽略而只看最后的单个模块缓存添加的结果, 只有整个整形的模块缓存才考虑缓存删除.

所以, 这样约定的情况下, 缓存的添加以最后一步, 即`Backbone.history.handlers`或`moduleStates`的添加为有效添加. 这样, 缓存添加成为了一步到位的概念.

=== 了解缓存变量

.缓存变量格式
|===
|缓存变量 |格式 |备注

| `Backbone.history.handlers`
| [ { route: .., callback: func }, { route: .., callback: func } ]
| 缓存添加的顺序是入栈, 即push

| `require.script`
| dom获取的对象, 数组
| 缓存添加的顺序是入栈

| `require.defined`
| { 模块名1: 方法, 模块名2: 方法 }
| 有效清理方法是delete

| `require.urlFetched`
| { 模块路径1 : true, 模块路径2 : true }
| 有效清理方法是delete
|===

== 安全的删除

=== 怎样安全的删除

. 有序的删除? 我理解为精确的查找才是需求

. 维持`Backbone.Router`是有序的

=== 考虑多线程的删除

删除数组的内容注意多线程问题::

	1. 数组是引用变量, 所以多个方法对同一数组同时进行修改, 即并联删除
		.. 那么各个方法的过程中,  数组的长度与index序号会有未知变化
	2. 所以避免使用splice进行删除, splice是依赖序号来进行寻找元素
	3. 猜想方案: 对数组的元素标记toDete属性, 无论哪个方法对其标记toDelete都执行删除

=== js特点

1. 单线程
2. 代码是按顺序执行
3. 毫秒级的执行速度
4. setTimeOut改变执行顺序, 但js代码还是按序执行

js的特点, 保证任何对列表的操作都在一个线程里操作,
所以我理解这里的一个线程指的是, 一个堆栈队列里处理添加和删除

=== 在用户使用的角度来考虑缓存的删除


=== 安全删除方案

==== 方案1 串联式

堆栈式的列表操作
创建一个队列, 把添加和删除的操作都入栈队列中, 有序的进行操作, 这确保列表操作很安全, 但不符合用户体验, 请看:
以加载与跳转, 思考用户者体验
新模块要加载, 返回就模块可以立即执行

.案例分析
|===
|情形 |用户需求 |串联模式 |理想效果

|只进入moduleA后, 跳转moduleB中执行跳转moduleC,
|只执行moduleC
|在moduleB成功加载才开始加载moduleC, 这不合理
|moduleB, moduleC都并联加载, 只显示moduleC

|只进入moduleA后, 跳转moduleB中执行跳转moduleA,
|只执行moduleA
|在moduleB成功加载才返回moduleA, 期间一直是loading状态, 等于假死
|moduleB异步加载, 不影响moduleA使用
|===

 结论:不可能添加和删除都在同一线程

==== 方案2

* 并联添加模块
* 正确定义单个模块缓存的成功添加, 以上已说明
* 删除时机选择: 在单个模块缓存的成功添加后执行模块缓存的删除,
 只有添加成功, 才做删除, 保证用户体验

思考问题:

1. 添加的对象可能是此时执行删除的对象?? 不会的, 因为删除的对象是最早添加的模块
2. 删除的对象可能是此时执行添加的对象??
    .. 不会的, 因为删除的过程很快, 不存在空隙去添加? 若有可能都是排在删除后才会执行添加
    .. 而且没有完整添加缓存完毕的对象不可能在删除范围内
3. 删除中是否有可能添加??
    .. 因为删除的过程是一气呵成的连贯动作, 而添加过程是由require代码控制, 必然是js的按序执行的
4. script的添加是如何执行??

 require里对需要加载的模块就会执行生成script标签请求数据.
 当一个模块加载成功, 检测其依赖, 若未加载, 同理生成script,
 所以这都是js代码控制的生成的, 都应该按序进行

**结论: 方案2是当前较优选择.**

== 删除具体操作

=== 添加变量控制模块缓存的数量

=== 添加方法检测缓存数量并删除多余的缓存模块

=== 请看附件`nuui-moduleLoader.js`


== 测试模块缓存, 测试清理效果

环境: nuui框架

=== 测试1 - 大型模块的加载缓存

==== 测试的对象

测试对象: 大型模块, `obj/string/number`

==== 测试的流程

略

//1. 建立6mb的js文件, 建立新`cacheModule`作为动态模块添加
//2. 执行nuui
//    .. 正常情况是6-8k内存
//    .. 动态加载5个`cacheModule`, 内存上升到50k内存
//    .. 2分钟后是16k内存
//    .. 15分钟后是16k内存
//
//3. 缓存测试
//    .. 给view添加巨量的`string`作为属性, 内存飙升后, 清理`require`与`Backbone.history`都只能清理1/4内存
//    .. 给view添加巨量的`ary`作为属性, 内存飙升后, 清理`require`与`Backbone.history`都能有效清理

==== 结论

除了string的模块, 其他数据类型的模块的缓存都很好的清理

//1. `string`是基本数据, 基本数据的内存不容易清理
//2. `ary`是变量, 是引用,
//    .. 存在的意义是引用数据,
//    .. 若没有了被引用的需要, 那么就被浏览器自定清理, 区别于基本数据
//3. 浏览器的缓存清理是我暂时不理解的, 只知道
//    .. 处理时间不稳定
//    .. 处理效果不稳定
//    .. 切换页面可以促使浏览器去检测页面不被引用的变量清理

=== 测试2 - 大量模块的加载缓存

==== 测试的对象

测试对象: 大量模块, `obj/string/number`

==== 测试坐标, 维度, 环境

// todo
//单个操作周期: 由缓存任务启动到静止的过程, 即ui操作请求数据到文件onload执行删除模块缓存.

nuui项目特点:

	* 权限跳转: 新模块不执行, 跳转另一新模块页面, 可理解为串联添加任务

理想效果:

	* 基本要求: 不出现崩溃
	* 网络差但可以随意操作的范围:  缓存A的任何操作
	* 特别疑惑之处

缓存变化说明:

	* 缓存列表添加:  漫长得会发生任何操作, 并联下载模块, 但串联添加模块缓存
	* 缓存列表删除:  即时删除, 不会并联删除
	* 缓存列表重新排序:  即时重排, 不会并联重排

测试执行动作:

	* 并联添加任务, 改变缓存容量.

测试执行动作的组合:

	* 没有排序:
		** 测试1: 并联添加任务, 串联完成缓存添加, 只实现最后一个
		** 测试2: 并联添加任务后的随意操作, 串联完成缓存添加, 缓存只保留最近添加的缓存
		** 测试3: 串联式的添加任务, 缓存只保留最近添加的缓存

	* 有排序
		** 特点是模块之间的调整会更新排序, 直接影响删除的

==== 具体测试流程与效果

----
条件: 网速慢, 模块容量只有1个, 表示没有排序

基本测试
测试1:
    情形:
        在模块A中, 跳转新模块B中跳转新模块C
    表现:
        等待后只显示moduleC
    原理:
        1. 模块B先完成缓存添加, 也是先清理模块A缓存;
        2. 模块C加载完毕, 也对模块B的缓存进行清理;
        3. 页面显示正常

多模块加载测试
测试2 - 1:
    情形:
        在缓存模块A, 跳转新模块B中跳转新模块C中, 在moduleB下载完毕但没有下载完C之前, 点击跳转moduleA
    表现:
        显示moduleA页面, 没有执行moduleB/C
    原理:
        1. moduleB下载完, 清理moduleA缓存
        2. 操作跳转moduleA, 所以重新加载moduleA, 这耗时很短, 可能因为浏览器缓存
        3. 显示出moduleA, 清理moduleB
        4. 后来moduleC下载完, 清理moduleA缓存, 但显示的页面是moduleA, 所以当下一步跳转moduleA页面要重新加载

测试2 - 2:
    情形:
        在模块A中, 跳转新模块B中跳转新模块C中, 跳转moduleA页面
    表现:
        立即就跳转到moduleA的页面, 没有显示过moduleB/C,

    原理:
        1. moduleB/C未下载完, moduleA的跳转是不需要加载的
        2. moduleB下载完, 清理moduleA缓存
        3. moduleC下载完, 清理moduleB缓存
        4. 所以现在的缓存只有moduleC, 但显示的页面是moduleA, 所以当下一步跳转moduleA页面要重新加载

权限测试
测试3 - 1:
    情形:
        网速慢, 在moduleA跳转moduleB中, 因moduleB的页面权限不通过, 跳转回moduleA的指定权限页面
    表现:
        等待一段时间后直接显示moduleA的指定权限页面
    原理:
		1. 等待moduleB加载完毕
		2. 执行删除缓存moduleA
		3. 路由moduleB的页面, 权限不通过, 路由到moduleA
		4. 加载moduleA, 等待时间不长, 可能因为浏览缓存是没有即时清理
		5. 路由到moduleA的指定权限页面

测试3 - 2:
    情形:
        网速慢, 在moduleA跳转moduleB权限受限页面中, 跳转moduleA页面
    表现:
        moduleA里的页面流畅
    原理:
		1. moduleB加载很缓慢
		2. moduleA页面有缓存所以流畅跳转
		3. moduleB加载完毕, 清理moduleA
		4. 但不会执行moduleB, 因为期间已经跳转moduleA, 受到hashChange变量控制, 不会执行moduleB页面
		5. 之后跳转moduleA是需要重新加载moduleA, 但耗时很短

测试证明:
	1. 若没有精确查找删除Backbone.history.handlers, 使路由事件混乱起来, 变成失控
	2. 网速不影响在一个模块内的跳转
	3. 在新模块加载完成之前的缓存模块跳转是顺畅的
	4. 在新模块加载完整之前新跳转的模块作为最终目标显示模块, 期间的加载模块都不会显示
	5. hashChange的意义:
		1. 保护一个操作周期内, 串联式的多个缓存添加中, 只实现最后一个模块缓存的页面
	6. moduleList / moduleState的意义
		1. 记录缓存中的模块,
			1. 意义1: 阻止不存在的页面重新加载模块;
			2. 意义2: 作为缓存模块的信息, 提供缓存模块数量, 加载的缓存模块的顺序, 最近加载的缓存模块与最早加载的缓存模块
			3. 但不是最近访问的模块, 因为加载的模块不一定被访问
		2. 建议新模块下载后没有立即执行的话, 执行一次reorder

条件: 网速慢, 模块容量只有2个, 表示有排序
目的是检测重新排序
测试4:
    情形:
        模块A, 跳转模块B中, 跳转C页面( 已知C页面权限不通过, 跳转至模块A页面 )
    表现:
        显示的只有A模块的权限指定页面
    原理:
		1. moduleB加载后moduleList = [ A, B ]
		2. moduleC加载后moduleList = [ A, B, C ]
		3. 清理moduleA
		4. 执行权限验证, 不通过, 跳转至moduleA, 加载moduleA
		5. 加载完成后, 清理moduleB缓存, 执行显示moduleA指定页面
    思考:
       我认为不合理, 实际上是没有访问过B, 清理的应该是B, 可以在B成功加载后遇上hashChange执行reorderModuleList
       因为原理上moduleB只是加载过, 没有访问过, moduleA的下一个访问模块是moduleC, moduleB应该是作为最早的模块排列在moduleList队列, 但毅明认为模块缓存管理不是用户体验角度思考, 是程序角度的, 所以moduleList是缓存加载列表, 不是访问列表

测试4 - 1:
    情形:  模块A, 跳转模块B中, 跳转C页面( 已知C页面权限不通过, 跳转至模块A页面 ), 但网络是
    表现:  显示的只有A模块的权限指定页面
    原理:

测试5:
    情形:  模块A, 跳转模块B中, 跳转C页面中, 在B完成C下载中的情况重新跳转B,
    表现:  可以进入B, C即使下载了也不执行

----